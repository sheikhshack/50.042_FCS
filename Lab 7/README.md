# Lab 7 - RSA

## Contents Of Code
1. `RSA_handin1.py` has the implememntation for both Hand-In 1 requirements
2. `RSA_handin2.py` has the implememntation for both Hand-In 2 requirements, with demo-ed exchange between me and 'friend' plus all the attacks
3. Otherfiles
    - `friendkey.pem.pub` -> friend's pubkey
    - `friend.sign` -> friend's digital signature
    - will also generate `encrypted_msg` and `decrypted_msg` for Hand In 1, ouitput will be printed in terminal as well :)


## Part 1 & 2 Writeup

### Limitation of Protocol Attacks

The 2 attacks descibed are reliant on the malleability and deterministic property of the RSA Encryption mechanism

**RSA Encryption Protocol Attack**
Under this attack, the attacker has some idea as to the relationship between an actual message (m) from user Alice and his own malicious message (m'). In the example of this lab, we utilised m = 100, and m' = 200, so attacker knowing the relationship being scale = 2. In this case, the limitation is that the attack will only work if the protocol uses a scheme such that an encryption of a message will lead to a deterministic multipicative outcome, such that `ENC(a) * ENC(b) = ab^e % n`, and the attacker knowing the scale-relationship between m and m'.

Thus, to render this attack useless, we can utilise a padding scheme which will assist us in introducing some form of randomness to this deterministic protocol. As mentioned in the lab handout, OAEP is one such solution


**RSA Digital Signature Attack**
Under this attack, the attacker will first generate a random data to function as the signature. Attacker will then create the corresponding message for this signature by simply ensuring that `m = s^e % n`. In this case, the limitation is that it will only work for a protocol that have no added measure as to verifying if a signature is truly generated by a privatekey and not some mathematical exponentiation of message based on predetermined signature

Thus, to render this attack useless, we can utilise hash functions on a given message m. By doing so, attacker will now have to ensure that went the public key is applied to the 'random-ed signature', it will lead to the crafted m. This will be extremely difficult, since attacker has to ensure that m is such that `HASH(m) = s^e % n`, esentially finding an  m for a given HASH(m)

## Part 3 Writeup

### Explain the purpose of Optimal Asymetric Encryption Padding (OAEP) to encrypt and decrypt using RSA. Explain how it works.

OAEP is a padding scheme used together with RSA to achieve primarily these 2 essential features:
1. Introduce an element of randomness to the determinisitic nature of RSA, converting it to a more probabilistic scheme (so as to prevent attacks like those the RSA Encryption Protocol Attack )
2. Prevent partial decryption of ciphertext by reinforcing the one-wayness of encryption/decryption from the attacker standpoint

Hence, OAEP pretty much aims to solve the malleable property of the original RSA encryption scheme

OAEP utilises a feistel network to first transform the plaintext messages prior to their encryption. For encryption, 
1. The message block is first transformed to m bits.
2. Message is then XOR-ed with G( r ), where r is a one-time random number (nonce),  G is a random oracle function transforming k-bit r to m-bit
3. Result from 2 (m_phase1) `m-bits` then undergoes H(m_phase1) `k-bits` and proceed to be XOR-ed with the original k-bit r. In this step, H refers to another random oracle function that transforms m-bit to k-bit. Result from this step is m_phase2
4. Finally, we append m_phase1 | m_phase2, resulting in `m+k bits`, which we then encrypt

For decryption, we proceed to do the inverse, which will allow us to achieve back the original message, given the utilisation of this feistel network


### Explain the purpose of Probabilistic Signature Scheme (PSS) to sign and verify using RSA. Explain how it works.

The core purpose of PSS is to enhance the security of signatures. Under this mission, PSS seeks to introduce seemingly random properties to a signature via encoding/transformations, such that same messages may lead to different signatures, thus enhancing security by introducing probablistic signatures.

For terminologies sake:
- *MGF* -> Mask Generation Function (usually a hash function is used to meet this function's objective)
- *EM* -> Encoded Message, has a length of at most n-1 bits, where n = RSA modulus
- *DB* -> Data Block
- *fixed_padding1 / fixed_padding2 -> this is accessible to both sender and receipient


Let's say we want to sign a message(m). The way that an example of a PSS works is as such:

*ENCODING STEPS*
1. Generate a random salt value
2. Forms a string m1 = fixed_padding1 | hash(m) | salt
3. Compute hash(m1) and concat it with fixed_padding2 and the salt, giving block DB
4. Apply MGF to string m1 to combute dbMASK
5. dbMask XOR DB to compute maskedDB
6. Encoded message EM is obtained by concatenating maskedDB, hash(m1) and a fixed padding

With the generated EM, we can then simply sign it using the private key to encrypt the EM. For verification, the receipient will need to obtain the salt value, and simply check if he/she too can obtain the EM. The salt value in this encoding standard is what leads to the different signatures for same messages


*Credits to Christof Paar on youtube for the PSS method, https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg*



